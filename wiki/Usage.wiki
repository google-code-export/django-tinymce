#summary Using `tinymce`.
#labels Featured

= Usage =

The application can enable TinyMCE for one form field using the `widget` keyword argument of `Field` constructors or for all textareas on a page using a view.

== Using the widget ==
The TinyMCE widget can be enabled by setting it as the widget for a formfield. For example, to use a nice big TinyMCE widget for the content field of a flatpage form you could use the following code:

{{{
class FlatpageForm(ModelForm):
    content = forms.CharField(widget=TinyMCE(
        attrs={'cols': 80, 'rows': 30},
    ))

    class Meta:
        model = Flatpage
}}}

The widget accepts the following keyword arguments:

*`content_language`* (default: `django.utils.translation.get_language_code()`)
  The language of the widget content. Will be used to set the `language`, `directionality` and `spellchecker_languages` configuration options of the TinyMCE editor.

*`mce_attrs`* (default: `{}`)
  Extra TinyMCE configuration options.

== Using the view ==

If you cannot or will not change the widget on a form you can also use the `tinymce-js` named view to convert some or all textfields on a page to TinyMCE editors. On the template of the page, add the following lines to the `HEAD` element:
{{{
<script type="text/javascript" src="{{ MEDIA_URL }}js/tiny_mce/tiny_mce.js"></script>
<script type="text/javascript" src="{% url tinymce-js "NAME" %}"></script>
}}}

The `NAME` allows you to create multiple TinyMCE configurations. Now create a template containing the Javascript initialization code. It should be placed in the template path as `NAME/tinymce_textareas.js` or `tinymce/NAME_textareas.js`.

Example:

{{{
tinyMCE.init({
    mode: "textareas",
    theme: "advanced",
    plugins: "spellchecker,directionality,paste,searchreplace",
    language: "{{ language }}",
    directionality: "{{ directionality }}",
    spellchecker_languages : "{{ spellchecker_languages }}",
    spellchecker_rpc_url : "{{ spellchecker_rpc_url }}"
});
}}}

This example also shows all variables you can use in the template.

== External link and image lists ==

The TinyMCE link and image dialogs can be enhanced using a listbox with predefined entries. These entries are filled using a variable loaded from an external Javascript. The `tinymce` application can render these files for you.

To use a predefined link list, add the `external_link_list_url` option to the `mce_attrs` keyword argument to the widget (or the template if you use the view). The value is a URL that points to a view that fills a list of 2-tuples and calls `tinymce.views.render_to_link_list`. The first element of the tuple is the link name and the second element the URL.

Example:

Create the widget:
{{{
field = forms.CharField(widget=TinyMCE(
    mce_attrs={'external_link_list_url': reverse('someapp.views.someview')})
}}}

Create the view:
{{{
from tinymce.views import render_to_link_list
def someview(request):
    objects = ...
    link_list = [(unicode(obj), obj.get_absolute_url()) for obj in objects]
    return render_to_link_list(link_list)
}}}

As an example, the `tinymce` application contains a predefined view that lists all `django.contrib.flatpages` objects: `tinymce.views.flatpages_link_list`.

Image lists work exactly the same way, just use the TinyMCE `external_image_list_url` configuration option and call `tinymce.views.render_to_image_list` from your view.